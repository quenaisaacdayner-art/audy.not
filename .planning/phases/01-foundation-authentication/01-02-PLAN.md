---
phase: 01-foundation-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/middleware.ts
  - src/middleware.ts
  - src/lib/validations/auth.ts
autonomous: true

must_haves:
  truths:
    - "Supabase client can be created in browser context"
    - "Supabase client can be created in server context"
    - "Middleware refreshes auth tokens on each request"
    - "Auth validation schemas enforce email format and password length"
  artifacts:
    - path: "src/lib/supabase/client.ts"
      provides: "Browser Supabase client factory"
      exports: ["createClient"]
    - path: "src/lib/supabase/server.ts"
      provides: "Server Supabase client factory"
      exports: ["createClient"]
    - path: "src/middleware.ts"
      provides: "Next.js middleware for auth"
      min_lines: 20
    - path: "src/lib/validations/auth.ts"
      provides: "Zod schemas for auth forms"
      exports: ["signupSchema", "loginSchema"]
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/supabase/middleware.ts"
      via: "updateSession import"
      pattern: "import.*updateSession.*middleware"
    - from: "src/lib/supabase/middleware.ts"
      to: "@supabase/ssr"
      via: "createServerClient"
      pattern: "createServerClient"
---

<objective>
Create Supabase client utilities, auth middleware, and validation schemas.

Purpose: Establish the infrastructure layer that handles authentication state. The middleware ensures sessions persist across requests, and the validation schemas ensure consistent input validation across auth forms.

Output: Working Supabase clients for browser and server, middleware that refreshes tokens, and Zod schemas for auth validation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase client utilities</name>
  <files>
    src/lib/supabase/client.ts
    src/lib/supabase/server.ts
    src/lib/supabase/middleware.ts
  </files>
  <action>
    Create src/lib/supabase/ directory and three files following the official @supabase/ssr patterns.

    **src/lib/supabase/client.ts** (browser client):
    ```typescript
    import { createBrowserClient } from '@supabase/ssr'

    export function createClient() {
      return createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      )
    }
    ```

    **src/lib/supabase/server.ts** (server client):
    ```typescript
    import { createServerClient } from '@supabase/ssr'
    import { cookies } from 'next/headers'

    export async function createClient() {
      const cookieStore = await cookies()

      return createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
          cookies: {
            getAll() {
              return cookieStore.getAll()
            },
            setAll(cookiesToSet) {
              try {
                cookiesToSet.forEach(({ name, value, options }) =>
                  cookieStore.set(name, value, options)
                )
              } catch {
                // Called from Server Component - ignore
              }
            },
          },
        }
      )
    }
    ```

    **src/lib/supabase/middleware.ts** (session refresh utility):
    ```typescript
    import { createServerClient } from '@supabase/ssr'
    import { NextResponse, type NextRequest } from 'next/server'

    export async function updateSession(request: NextRequest) {
      let supabaseResponse = NextResponse.next({
        request,
      })

      const supabase = createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
          cookies: {
            getAll() {
              return request.cookies.getAll()
            },
            setAll(cookiesToSet) {
              cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))
              supabaseResponse = NextResponse.next({
                request,
              })
              cookiesToSet.forEach(({ name, value, options }) =>
                supabaseResponse.cookies.set(name, value, options)
              )
            },
          },
        }
      )

      // IMPORTANT: Use getUser(), not getSession()
      // getUser() validates the token with Supabase Auth server
      const { data: { user } } = await supabase.auth.getUser()

      return { supabaseResponse, user }
    }
    ```
  </action>
  <verify>
    Run `npm run build` to confirm TypeScript compiles without errors
    Check that all three files exist in src/lib/supabase/
  </verify>
  <done>
    Supabase client utilities created for browser, server, and middleware contexts. All use @supabase/ssr cookie-based patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Next.js middleware for auth</name>
  <files>
    src/middleware.ts
  </files>
  <action>
    Create src/middleware.ts at the src/ directory root (not in app/).

    The middleware should:
    1. Refresh auth tokens on every request
    2. Allow public routes (/, /auth/callback)
    3. Redirect unauthenticated users away from protected routes

    ```typescript
    import { type NextRequest, NextResponse } from 'next/server'
    import { updateSession } from '@/lib/supabase/middleware'

    // Routes that don't require authentication
    const publicRoutes = ['/', '/auth/callback']

    export async function middleware(request: NextRequest) {
      const { supabaseResponse, user } = await updateSession(request)
      const path = request.nextUrl.pathname

      // Allow public routes
      if (publicRoutes.some(route => path === route || path.startsWith(route + '/'))) {
        return supabaseResponse
      }

      // Redirect unauthenticated users to home
      if (!user) {
        const url = request.nextUrl.clone()
        url.pathname = '/'
        return NextResponse.redirect(url)
      }

      return supabaseResponse
    }

    export const config = {
      matcher: [
        /*
         * Match all request paths except:
         * - _next/static (static files)
         * - _next/image (image optimization files)
         * - favicon.ico (favicon file)
         * - public files (images, etc)
         */
        '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
      ],
    }
    ```
  </action>
  <verify>
    Run `npm run dev` and visit http://localhost:3000 - should load without errors
    Run `npm run build` to confirm no TypeScript errors
  </verify>
  <done>
    Next.js middleware created that refreshes auth tokens and protects routes. Unauthenticated users are redirected from protected routes to home page.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Zod validation schemas for auth</name>
  <files>
    src/lib/validations/auth.ts
  </files>
  <action>
    Create src/lib/validations/ directory and auth.ts with Zod schemas.

    **src/lib/validations/auth.ts**:
    ```typescript
    import { z } from 'zod'

    export const signupSchema = z.object({
      email: z
        .string()
        .min(1, 'Email is required')
        .email('Invalid email address'),
      password: z
        .string()
        .min(1, 'Password is required')
        .min(8, 'Password must be at least 8 characters'),
    })

    export const loginSchema = z.object({
      email: z
        .string()
        .min(1, 'Email is required')
        .email('Invalid email address'),
      password: z
        .string()
        .min(1, 'Password is required'),
    })

    export type SignupInput = z.infer<typeof signupSchema>
    export type LoginInput = z.infer<typeof loginSchema>
    ```

    These schemas will be used by:
    - Client-side form validation (react-hook-form)
    - Server action validation (safeParse)
  </action>
  <verify>
    Run `npm run build` to confirm TypeScript compiles
    Verify types are exported correctly by checking for SignupInput and LoginInput exports
  </verify>
  <done>
    Zod validation schemas created for signup and login forms with email format and password length validation. Types are exported for use in forms and server actions.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes without TypeScript errors
2. `npm run dev` starts and home page loads
3. src/lib/supabase/ contains client.ts, server.ts, middleware.ts
4. src/middleware.ts exists at src/ root
5. src/lib/validations/auth.ts exports signupSchema, loginSchema, SignupInput, LoginInput
</verification>

<success_criteria>
- Supabase clients can be instantiated in browser and server contexts
- Middleware intercepts requests and refreshes tokens
- Protected routes redirect to home when unauthenticated
- Validation schemas enforce email format and 8-character password minimum
- All TypeScript types are correct and exported
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-02-SUMMARY.md`
</output>
